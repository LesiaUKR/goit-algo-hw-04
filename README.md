# goit-algo-hw-04

# Home work | Module 4 | Sorting algorithms

| Algorithm            | Small                | Medium               | Large                |
| --------------------: | :--------------------: | :--------------------: | :--------------------: |
| Insertion Sort       |              0.00040 |              0.05003 |              1.94403 |
| Merge Sort           |              0.00034 |              0.00399 |              0.02128 |
| Timsort (sorted)     |              0.00002 |              0.00023 |              0.00118 |
| Timsort (sort)       |              0.00001 |              0.00019 |              0.00122 |

1. **Insertion Sort**: Сортування вставками показує дуже повільну продуктивність на великих масивах, що підтверджує його часова складність O($n^2$). Для малих масивів цей алгоритм може бути достатньо ефективним, але його використання на великих даних не рекомендується через значний час виконання (2.18904 секунд на великому масиві).

2. **Merge Sort**: Сортування злиттям демонструє значно кращу продуктивність у порівнянні з сортуванням вставками на всіх розмірах масивів. Це узгоджується з його теоретичною складністю 
O(n logn). Навіть на великому масиві (10,000 елементів), час виконання залишається прийнятним (0.02029 секунд).

3. **Timsort (sorted)**: Timsort, який використовується у функції sorted(), показує найкращі результати серед всіх алгоритмів. Час виконання залишається дуже малим навіть для великих масивів (0.00121 секунд). Це підтверджує ефективність цього гібридного алгоритму, що поєднує сортування злиттям і сортування вставками.

4. **Timsort (sort)**: Результати аналогічні до Timsort (sorted), оскільки обидва використовують однаковий алгоритм. Це підтверджує стабільність та ефективність вбудованого алгоритму сортування в Python.

## Висновки

Поєднання сортування злиттям і сортування вставками в Timsort робить його надзвичайно ефективним. Це забезпечує кращу продуктивність у більшості випадків порівняно з чистими алгоритмами сортування.

Програмісти повинні віддавати перевагу вбудованим функціям сортування Python (sorted() і list.sort()), оскільки вони реалізовані на основі Timsort, що забезпечує найкращу продуктивність.

Використання власних реалізацій алгоритмів сортування виправдане лише у специфічних випадках, коли потрібно дотримуватися певних обмежень або умов.

Таким чином, результати порівняльного аналізу підтверджують теоретичні оцінки складності алгоритмів та демонструють ефективність використання вбудованих функцій сортування Python для широкого спектру завдань.